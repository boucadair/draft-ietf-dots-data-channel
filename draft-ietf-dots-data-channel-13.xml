<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-ietf-dots-data-channel-13"
     ipr="trust200902">
  <front>
    <title abbrev="DOTS Data Channel">Distributed Denial-of-Service Open
    Threat Signaling (DOTS) Data Channel</title>

    <author fullname="Tirumaleswar Reddy" initials="T." role="editor"
            surname="Reddy">
      <organization abbrev="McAfee">McAfee, Inc.</organization>

      <address>
        <postal>
          <street>Embassy Golf Link Business Park</street>

          <city>Bangalore</city>

          <region>Karnataka</region>

          <code>560071</code>

          <country>India</country>
        </postal>

        <email>kondtir@gmail.com</email>
      </address>
    </author>

    <author fullname="Mohamed Boucadair" initials="M." role="editor"
            surname="Boucadair">
      <organization>Orange</organization>

      <address>
        <postal>
          <street></street>

          <city>Rennes</city>

          <region></region>

          <code>35000</code>

          <country>France</country>
        </postal>

        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>

    <author fullname="Kaname Nishizuka" initials="K." surname="Nishizuka">
      <organization>NTT Communications</organization>

      <address>
        <postal>
          <street>GranPark 16F 3-4-1 Shibaura, Minato-ku</street>

          <city>Tokyo</city>

          <region></region>

          <code>108-8118</code>

          <country>Japan</country>
        </postal>

        <email>kaname@nttv6.jp</email>
      </address>
    </author>

    <author fullname="Liang Xia" initials="L." surname="Xia">
      <organization>Huawei</organization>

      <address>
        <postal>
          <street>101 Software Avenue, Yuhuatai District</street>

          <city>Nanjing, Jiangsu</city>

          <region></region>

          <code>210012</code>

          <country>China</country>
        </postal>

        <email>frank.xialiang@huawei.com</email>
      </address>
    </author>

    <author fullname="Prashanth Patil" initials="P." surname="Patil">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street></street>

          <street></street>

          <city></city>

          <country></country>
        </postal>

        <email>praspati@cisco.com</email>
      </address>
    </author>

    <author fullname="Andrew Mortensen" initials="A." surname="Mortensen">
      <organization>Arbor Networks, Inc.</organization>

      <address>
        <postal>
          <street>2727 S. State St</street>

          <city>Ann Arbor, MI</city>

          <region></region>

          <code>48104</code>

          <country>United States</country>
        </postal>

        <email>amortensen@arbor.net</email>
      </address>
    </author>

    <author fullname="Nik Teague" initials="N." surname="Teague">
      <organization>Verisign, Inc.</organization>

      <address>
        <postal>
          <street></street>

          <city></city>

          <region></region>

          <code></code>

          <country>United States</country>
        </postal>

        <email>nteague@verisign.com</email>
      </address>
    </author>

    <date />

    <workgroup>DOTS</workgroup>

    <keyword>Automation</keyword>

    <keyword>Security</keyword>

    <keyword>Mitigation</keyword>

    <keyword>Scrubbing</keyword>

    <keyword>Anti-DDoS</keyword>

    <keyword>Mitigator</keyword>

    <keyword>Security Center</keyword>

    <keyword>Filtering</keyword>

    <keyword>Resilience</keyword>

    <keyword>RESTCONF</keyword>

    <abstract>
      <t>The document specifies a Distributed Denial-of-Service Open Threat
      Signaling (DOTS) data channel used for bulk exchange of data that cannot
      easily or appropriately communicated through the DOTS signal channel
      under attack conditions.</t>

      <t>This is a companion document to the DOTS signal channel
      specification.</t>
    </abstract>

    <note title="Editorial Note (To be removed by RFC Editor)">
      <t>Please update these statements with the RFC number to be assigned to
      this document:<list style="symbols">
          <t>"This version of this YANG module is part of RFC XXXX;"</t>

          <t>"RFC XXXX: Distributed Denial-of-Service Open Threat Signaling
          (DOTS) Data Channel";</t>

          <t>reference: RFC XXXX</t>
        </list>Please update this statement with the RFC number to be assigned
      to I-D.ietf-dots-signal-channel:<list style="symbols">
          <t>"RFC YYYY: Distributed Denial-of-Service Open Threat Signaling
          (DOTS) Signal Channel";</t>
        </list></t>
    </note>
  </front>

  <middle>
    <section anchor="introduction" title="Introduction">
      <t>A distributed denial-of-service (DDoS) attack is an attempt to make
      machines or network resources unavailable to their intended users. In
      most cases, sufficient scale can be achieved by compromising enough
      end-hosts and using those infected hosts to perpetrate and amplify the
      attack. The victim of such attack can be an application server, a
      router, a firewall, an entire network, etc.</t>

      <t>As discussed in <xref target="I-D.ietf-dots-requirements"></xref>,
      the lack of a common method to coordinate a real-time response among
      involved actors and network domains inhibits the speed and effectiveness
      of DDoS attack mitigation. From that standpoint, DDoS Open Threat
      Signaling (DOTS) <xref target="I-D.ietf-dots-architecture"></xref>
      defines an architecture that allows a DOTS client to send requests to a
      DOTS server for DDoS attack mitigation. The DOTS approach is thus meant
      to minimize the impact of DDoS attacks, thereby contributing to the
      enforcement of more efficient defensive if not proactive security
      strategies. To that aim, DOTS defines two channels: the signal and the
      data channels (<xref target="channels"></xref>). <figure align="center"
          anchor="channels" title="DOTS Channels">
          <artwork><![CDATA[+---------------+                                 +---------------+
|               | <------- Signal Channel ------> |               |
|  DOTS Client  |                                 |  DOTS Server  |
|               | <=======  Data Channel  ======> |               |
+---------------+                                 +---------------+]]></artwork>
        </figure></t>

      <t>The DOTS signal channel is used to carry information about a device
      or a network (or a part thereof) that is under a DDoS attack. Such
      information is sent by a DOTS client to an upstream DOTS server so that
      appropriate mitigation actions are undertaken on traffic deemed
      suspicious. The DOTS signal channel is further elaborated in <xref
      target="I-D.ietf-dots-signal-channel"></xref>.</t>

      <t>As for the DOTS data channel, it is used for infrequent bulk data
      exchange between DOTS agents to significantly improve the coordination
      of all the parties involved in the response to the attack. Section 2 of
      <xref target="I-D.ietf-dots-architecture"></xref> mentions that the DOTS
      data channel is used to perform the following tasks:</t>

      <t><list style="symbols">
          <t>Creating aliases for resources for which mitigation may be
          requested.<vspace blankLines="1" />A DOTS client may submit to its
          DOTS server a collection of prefixes which it would like to refer to
          by an alias when requesting mitigation. The DOTS server can respond
          to this request with either a success or failure response (see
          Section 2 in <xref
          target="I-D.ietf-dots-architecture"></xref>).<vspace
          blankLines="1" />Refer to <xref target="identifier"></xref> for more
          details.</t>

          <t>Filter management, which enables a DOTS client to request the
          installation or withdrawal of traffic filters, dropping or
          rate-limiting unwanted traffic, and permitting white-listed traffic.
          <vspace blankLines="1" />Sample use cases for populating black- or
          white-list filtering rules are detailed hereafter: <list
              style="symbols">
              <t>If a network resource (DOTS client) detects a potential DDoS
              attack from a set of IP addresses, the DOTS client informs its
              servicing DOTS gateway of all suspect IP addresses that need to
              be blocked or black-listed for further investigation. The DOTS
              client could also specify a list of protocols and port numbers
              in the black-list rule. <vspace blankLines="1" />The DOTS
              gateway then propagates the black-listed IP addresses to a DOTS
              server which will undertake appropriate actions so that traffic
              originated by these IP addresses to the target network
              (specified by the DOTS client) is blocked.</t>

              <t>A network, that has partner sites from which only legitimate
              traffic arrives, may want to ensure that the traffic from these
              sites is not subjected to DDoS attack mitigation. The DOTS
              client uses the DOTS data channel to convey the white-listed IP
              prefixes of the partner sites to its DOTS server. <vspace
              blankLines="1" />The DOTS server uses this information to
              white-list flows originated by such IP prefixes and which reach
              the network.</t>
            </list>Refer to <xref target="filter"></xref> for more
          details.</t>
        </list></t>
    </section>

    <section anchor="notation" title="Notational Conventions and Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>

      <t>The reader should be familiar with the terms defined in <xref
      target="I-D.ietf-dots-architecture"></xref>.</t>

      <t>The terminology for describing YANG data modules is defined in <xref
      target="RFC7950"></xref>. The meaning of the symbols in tree diagrams is
      defined in <xref
      target="I-D.ietf-netmod-yang-tree-diagrams"></xref>.</t>

      <t>For the sake of simplicity, all of the examples in this document use
      "/restconf" as the discovered RESTCONF API root path. Many protocol
      header lines and message-body text within examples throughout the
      document are split into multiple lines for display purposes only. When a
      line ends with backslash ('\') as the last character, the line is
      wrapped for display purposes. It is to be considered to be joined to the
      next line by deleting the backslash, the following line break, and the
      leading whitespace of the next line.</t>
    </section>

    <section title="DOTS Data Channel: Design Overview">
      <t>Unlike the DOTS signal channel <xref
      target="I-D.ietf-dots-signal-channel"></xref>, which must remain
      operational even when confronted with signal degradation due to packets
      loss, the DOTS data channel is not expected to be fully operational at
      all times, especially when a DDoS attack is underway. The requirements
      for a DOTS data channel protocol are documented in <xref
      target="I-D.ietf-dots-requirements"></xref>.</t>

      <t>This specification does not require an order of DOTS signal and data
      channel creations nor mandates a time interval between them. These
      considerations are implementation- and deployment-specific.</t>

      <t>As the primary function of the data channel is data exchange, a
      reliable transport mode is required in order for DOTS agents to detect
      data delivery success or failure. This document uses RESTCONF <xref
      target="RFC8040"></xref> over TLS <xref target="RFC5246"></xref> over
      TCP as the DOTS data channel protocol (<xref
      target="fig_dots2"></xref>). <list style="empty">
          <t>Note: RESTCONF is a protocol based on HTTP <xref
          target="RFC7230"></xref> to provide CRUD (create, read, update,
          delete) operations on a conceptual datastore containing YANG data.
          Concretely, RESTCONF is used for configuring data defined in YANG
          version 1 <xref target="RFC6020"></xref> or YANG version 1.1 <xref
          target="RFC7950"></xref>, using the datastore concepts defined in
          the Network Configuration Protocol (NETCONF) <xref
          target="RFC6241"></xref>. RESTCONF combines the simplicity of the
          HTTP protocol with the predictability and automation potential of a
          schema-driven API. RESTCONF offers a simple subset of NETCONF
          functionality and provides a simplified interface using REST-like
          API which addresses the needs of the DOTS data channel and hence an
          optimal choice.</t>
        </list></t>

      <t><figure anchor="fig_dots2"
          title="Abstract Layering of DOTS Data Channel over RESTCONF over TLS">
          <artwork align="center"><![CDATA[+-------------------+
| DOTS Data Channel |
+-------------------+
|      RESTCONF     |
+-------------------+
|        TLS        |
+-------------------+
|        TCP        |
+-------------------+
|        IP         |
+-------------------+
]]></artwork>
        </figure></t>

      <t>The HTTP POST, PUT, PATCH, and DELETE methods are used to edit data
      resources represented by DOTS data channel YANG data modules. These
      basic edit operations allow the DOTS data channel running configuration
      to be altered by a DOTS client.</t>

      <t>DOTS data channel configuration information as well as state
      information can be retrieved with the GET method. An HTTP status-line
      header field is returned for each request to report success or failure
      for RESTCONF operations (Section 5.4 of <xref
      target="RFC8040"></xref>).</t>

      <t>The DOTS client performs the root resource discovery procedure
      discussed in Section 3.1 of <xref target="RFC8040"></xref> to determine
      the root of the RESTCONF API. After discovering the RESTCONF API root,
      the DOTS client uses this value as the initial part of the path in the
      request URI, in any subsequent request to the DOTS server. The DOTS
      server may support the retrieval of the YANG modules it supports
      (Section 3.7 in <xref target="RFC8040"></xref>). For example, a DOTS
      client may use RESTCONF to retrieve the vendor-specific YANG modules
      supported by the DOTS server.</t>

      <t>JavaScript Object Notation (JSON) <xref target="RFC7159"> </xref>
      payload is used to propagate the DOTS data channel specific payload
      messages that carry request parameters and response information, such as
      errors. This specification uses the encoding rules defined in <xref
      target="RFC7951"></xref> for representing DOTS data channel
      configuration data using YANG (<xref target="YANG"></xref>) as JSON
      text.</t>

      <t>A DOTS client registers itself to its DOTS server(s) in order to set
      up DOTS data channel-related configuration data and receive state data
      (i.e., non-configuration data) from the DOTS server(s).</t>

      <t>A single DOTS data channel between DOTS agents can be used to
      exchange multiple requests and multiple responses. To reduce DOTS client
      and DOTS server workload, DOTS client SHOULD re-use the same TLS
      session. While the communication to the DOTS server is quiescent, the
      DOTS client MAY probe the server to ensure it has maintained
      cryptographic state. Such probes can also keep alive firewall and/or NAT
      bindings. A TLS heartbeat <xref target="RFC6520"></xref> verifies that
      the DOTS server still has TLS state by returning a TLS message.</t>

      <t>In deployments where one or more translators (e.g., NAT44, NAT64,
      NPTv6) are enabled between the client's network and the DOTS server,
      DOTS data channel messages forwarded to a DOTS server must not include
      internal IP addresses/prefixes and/or port numbers; external
      addresses/prefixes and/or port numbers as assigned by the translator
      must be used instead. This document does not make any recommendation
      about possible translator discovery mechanisms. The following are some
      (non-exhaustive) deployment examples that may be considered: <list
          style="symbols">
          <t>Port Control Protocol (PCP) <xref target="RFC6887"></xref> or
          Session Traversal Utilities for NAT (STUN) <xref
          target="RFC5389"></xref> may be used to retrieve the external
          addresses/prefixes and/or port numbers. Information retrieved by
          means of PCP or STUN will be used to feed the DOTS data channel
          messages that will be sent to a DOTS server.</t>

          <t>A DOTS gateway may be co-located with the translator. The DOTS
          gateway will need to update the DOTS messages, based upon the local
          translator's binding table.</t>
        </list></t>

      <t>When a server-domain DOTS gateway is involved in DOTS data channel
      exchanges, the same considerations for manipulating the 'cdid' parameter
      as specified in <xref target="I-D.ietf-dots-signal-channel"></xref> MUST
      be followed by DOTS agents.</t>

      <t>A DOTS server may detect conflicting filtering requests from the same
      or distinct DOTS clients which belong to the same domain. For example, a
      DOTS client would request to blacklist a prefix, while another DOTS
      client would request to whitelist that same prefix. It is out of scope
      of this specification to recommend the behavior to follow for handling
      conflicting requests (e.g., reject all, reject the new request, notify
      an administrator for validation). DOTS servers SHOULD support a
      configuration parameter to indicate the behavior to follow when a
      conflict is detected. <xref target="install"></xref> specifies the
      behavior when no instruction is supplied to a DOTS server.</t>
    </section>

    <section title="DOTS Server(s) Discovery">
      <t>This document assumes that DOTS clients are provisioned with the
      reachability information of their DOTS server(s) using a variety of
      means (e.g., local configuration, or dynamic means such as DHCP). The
      specification of such means are out of scope of this document.</t>

      <t>Likewise, it is out of scope of this document to specify the behavior
      to follow by a DOTS client to place its requests (e.g., contact all
      servers, select one server among the list) when multiple DOTS servers
      are provisioned.</t>
    </section>

    <section anchor="YANG" title="DOTS Data Channel YANG Module">
      <section title="DOTS Aliases YANG Tree Structure">
        <t>The YANG module (ietf-dots-data-channel) allows to create aliases,
        for resources for which mitigation may be requested. Such aliases may
        be used in subsequent DOTS signal channel exchanges to refer more
        efficiently to the resources under attack. The tree structure for DOTS
        aliases is as follows:</t>

        <t><figure>
            <artwork><![CDATA[module: ietf-dots-data-channel
    +--rw aliases
       +--rw dots-client* [cuid]
          +--rw cuid     string
          +--rw cdid?    string
          +--rw alias* [alias-name]
             +--rw alias-name           string
             +--rw target-prefix*       inet:ip-prefix
             +--rw target-port-range* [lower-port upper-port]
             |  +--rw lower-port    inet:port-number
             |  +--rw upper-port    inet:port-number
             +--rw target-protocol*     uint8
             +--rw target-fqdn*         inet:domain-name
             +--rw target-uri*          inet:uri
      ...]]></artwork>
          </figure>This structure is aligned with <xref
        target="I-D.ietf-dots-signal-channel"></xref>.</t>
      </section>

      <section title="Filter YANG Tree Structure">
        <t></t>

        <section title="DOTS ACL YANG Profile">
          <t>This document augments the Access Control List (ACL) YANG module
          <xref target="I-D.ietf-netmod-acl-model"></xref> for managing DOTS
          filtering rules. The notion of ACL is explained in Section 1 of
          <xref target="I-D.ietf-netmod-acl-model"></xref>.</t>

          <t>Examples of ACL management in a DOTS context include, but not
          limited to:</t>

          <t><list style="symbols">
              <t>Black-list management, which enables a DOTS client to inform
              a DOTS server about sources from which traffic should be
              discarded.</t>

              <t>White-list management, which enables a DOTS client to inform
              a DOTS server about sources from which traffic should always be
              accepted.</t>

              <t>Filter management, which enables a DOTS client to request the
              installation or withdrawal of traffic filters, dropping or
              rate-limiting unwanted traffic and permitting white-listed
              traffic.</t>
            </list></t>

          <t>DOTS implementations MUST support the following features defined
          in <xref target="I-D.ietf-netmod-acl-model"></xref>:</t>

          <t><list style="empty">
              <t>match-on-ipv4, match-on-ipv6, match-on-tcp, match-on-udp,
              match-on-icmp, ipv4, ipv6, and acl-aggregate-stats.</t>
            </list></t>

          <t>Given that DOTS data channel does not deal with interfaces, the
          support of the "ietf-interfaces" module <xref
          target="RFC7223"></xref> and its augmentation in the
          "ietf-access-control-list" module are not required for DOTS.
          Specifically, the support of interface-related features and branches
          (e.g., interface-attachment, interface-stats) of the ACL YANG module
          is not required.</t>

          <t>The following forwarding actions MUST be supported: <list
              style="empty">
              <t>'accept' and 'drop'</t>
            </list></t>

          <t>The support of 'reject' action is NOT RECOMMENDED because it is
          not appropriate in the context of DDoS mitigation. Generating ICMP
          messages to notify drops when mitigating a DDoS attack will
          exacerbate the DDoS attack. Further, it will be used by an attacker
          as an explicit signal that the traffic is being blocked.</t>

          <t>The following tree structure provides the excerpt of the
          "ietf-access-control-list" module to be supported by DOTS
          implementations.</t>

          <t><figure>
              <artwork><![CDATA[    +--rw access-lists
       +--rw acl* [name]
          +--rw name    string
          +--rw type?   acl-type
          +--rw aces
             +--rw ace* [name]
                +--rw name          string
                +--rw matches
                |  +--rw (l3)?
                |  |  +--:(ipv4)
                |  |  |  +--rw ipv4 {match-on-ipv4}?
                |  |  |     +--rw dscp?                       inet:dscp
                |  |  |     +--rw ecn?                        uint8
                |  |  |     +--rw length?                     uint16
                |  |  |     +--rw ttl?                        uint8
                |  |  |     +--rw protocol?                   uint8
                |  |  |     +--rw source-port-range!
                |  |  |     |  +--rw lower-port    inet:port-number
                |  |  |     |  +--rw upper-port?   inet:port-number
                |  |  |     |  +--rw operation?    operator
                |  |  |     +--rw destination-port-range!
                |  |  |     |  +--rw lower-port    inet:port-number
                |  |  |     |  +--rw upper-port?   inet:port-number
                |  |  |     |  +--rw operations?   operator
                |  |  |     +--rw ihl?                        uint8
                |  |  |     +--rw flags?                      bits
                |  |  |     +--rw offset?                     uint16
                |  |  |     +--rw identification?             uint16
                |  |  |     +--rw destination-ipv4-network?   inet:ipv4-prefix
                |  |  |     +--rw source-ipv4-network?        inet:ipv4-prefix
                |  |  +--:(ipv6)
                |  |     +--rw ipv6 {match-on-ipv6}?
                |  |        +--rw dscp?                       inet:dscp
                |  |        +--rw ecn?                        uint8
                |  |        +--rw length?                     uint16
                |  |        +--rw ttl?                        uint8
                |  |        +--rw protocol?                   uint8
                |  |        +--rw source-port-range!
                |  |        |  +--rw lower-port    inet:port-number
                |  |        |  +--rw upper-port?   inet:port-number
                |  |        |  +--rw operation?    operator
                |  |        +--rw destination-port-range!
                |  |        |  +--rw lower-port    inet:port-number
                |  |        |  +--rw upper-port?   inet:port-number
                |  |        |  +--rw operations?   operator
                |  |        +--rw next-header?                uint8
                |  |        +--rw destination-ipv6-network?   inet:ipv6-prefix
                |  |        +--rw source-ipv6-network?        inet:ipv6-prefix
                |  |        +--rw flow-label?                 inet:ipv6-flow-label
                |  +--rw (l4)?
                |     +--:(tcp)
                |     |  +--rw tcp {match-on-tcp}?
                |     |     +--rw sequence-number?          uint32
                |     |     +--rw acknowledgement-number?   uint32
                |     |     +--rw data-offset?              uint8
                |     |     +--rw reserved?                 uint8
                |     |     +--rw flags?                    bits
                |     |     +--rw window-size?              uint16
                |     |     +--rw urgent-pointer?           uint16
                |     |     +--rw options?                  uint32
                |     +--:(udp)
                |     |  +--rw udp {match-on-udp}?
                |     |     +--rw length?   uint16
                |     +--:(icmp)
                |        +--rw icmp {match-on-icmp}?
                |           +--rw type?             uint8
                |           +--rw code?             uint8
                |           +--rw rest-of-header?   uint32
                +--rw actions
                |  +--rw forwarding    identityref
                |  +--rw logging?      identityref
                +--ro statistics {acl-aggregate-stats}?
                   +--ro matched-packets?   yang:counter64
                   +--ro matched-octets?    yang:counter64
]]></artwork>
            </figure></t>
        </section>

        <section title="DOTS Augmentation to the IETF-ACL YANG Module">
          <t>This document defines the DOTS Data Channel YANG to augment the
          "ietf-access-control-list" module to support filters based on the
          DOTS client unique identifier (cuid) and/or the client domain
          identity (cdid), to support rate-limit action (rate-limit), and to
          handle fragmented packets (fragments). The tree structure for
          augmented DOTS filtering rules is as follows:</t>

          <t><figure>
              <artwork><![CDATA[  augment /ietf-acl:access-lists/ietf-acl:acl:
    +--rw cuid        -> /aliases/dots-client/cuid
    +--rw cdid?       -> /aliases/dots-client/cdid
    +--rw lifetime    int32
  augment /ietf-acl:access-lists/ietf-acl:acl/ietf-acl:aces
          /ietf-acl:ace/ietf-acl:actions:
    +--rw rate-limit?   decimal64
  augment /ietf-acl:access-lists/ietf-acl:acl/ietf-acl:aces
          /ietf-acl:ace/ietf-acl:matches/ietf-acl:l3/ietf-acl:ipv4:
    +--rw v4-fragments?   empty
  augment /ietf-acl:access-lists/ietf-acl:acl/ietf-acl:aces
          /ietf-acl:ace/ietf-acl:matches/ietf-acl:l3/ietf-acl:ipv6:
    +--rw v6-fragments?   empty
  augment /ietf-acl:access-lists:
    +--rw dots-acl-order
       +--rw acl-set* [cuid name]
          +--rw cuid                  -> /ietf-acl:access-lists/acl/cuid
          +--rw cdid?                 -> /ietf-acl:access-lists/acl/cdid
          +--rw name                  -> /ietf-acl:access-lists/acl/name
          +--rw type?                 -> /ietf-acl:access-lists/acl/type
]]></artwork>
            </figure></t>

          <t>Filtering fragments adds an additional layer of protection
          against a DoS attack that uses non-initial fragments only. When
          there is only Layer 3 information in the ACL entry and the fragments
          keyword is present, for non-initial fragments matching the ACL
          entry, the 'deny' or 'permit' action associated with the ACL entry
          will be enforced. For initial or non-fragment matching the ACL
          entry, the next ACL entry will be processed. When there is both
          Layer 3 and Layer 4 information in the ACL entry and the fragments
          keyword is present, the ACL action is conservative for both permit
          and deny actions. The actions are conservative to not accidentally
          deny a fragmented portion of a flow because the fragments do not
          contain sufficient information to match all of the filter
          attributes. In the deny action case, instead of denying a
          non-initial fragment, the next ACL entry is processed. In the permit
          case, it is assumed that the Layer 4 information in the non-initial
          fragment, if available, matches the Layer 4 information in the ACL
          entry.</t>
        </section>
      </section>

      <section title="DOTS Data Channel YANG Module">
        <t><figure>
            <artwork><![CDATA[<CODE BEGINS> file "ietf-dots-data-channel@2018-01-18.yang"

module ietf-dots-data-channel {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-dots-data-channel";

  prefix "data-channel";

  import ietf-inet-types {prefix "inet";}
  import ietf-access-control-list {prefix "ietf-acl";}

  organization "IETF DDoS Open Threat Signaling (DOTS) Working Group";

  contact
    "WG Web:   <https://datatracker.ietf.org/wg/dots/>
     WG List:  <mailto:dots@ietf.org>

     Editor:  Konda, Tirumaleswar Reddy 
              <mailto:TirumaleswarReddy_Konda@McAfee.com>

     Editor:  Mohamed Boucadair 
              <mailto:mohamed.boucadair@orange.com>

     Author:  Kaname Nishizuka 
              <mailto:kaname@nttv6.jp>

     Author:  Liang Xia 
              <mailto:frank.xialiang@huawei.com>

     Author:  Prashanth Patil 
              <mailto:praspati@cisco.com>

     Author:  Andrew Mortensen 
              <mailto:amortensen@arbor.net>

     Author:  Nik Teague 
              <mailto:nteague@verisign.com>";

  description
    "This module contains YANG definition for configuring
     aliases for resources and filtering rules using DOTS
     data channel.

     Copyright (c) 2018 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.";

  revision 2018-01-18 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: Distributed Denial-of-Service Open Threat 
                 Signaling (DOTS) Data Channel";
  }

  container aliases {
    description "Top level container for aliases";

    list dots-client {
      key "cuid";
      description 
        "List of DOTS clients"; 
      leaf cuid {
        type string;
        description 
          "A unique identifier that is randomly 
           generated by a DOTS client to prevent 
           request collisions.";
        reference
          "RFC YYYY: Distributed Denial-of-Service
                     Open Threat Signaling (DOTS) Signal Channel"; 
       }
       leaf cdid {
         type string; 
         description  
           "A client domain identifier conveyed by a
            server-domain DOTS gateway to a remote DOTS server.";
         reference
          "RFC YYYY: Distributed Denial-of-Service
                     Open Threat Signaling (DOTS) Signal Channel"; 
      }
      list alias {
        key "alias-name";
        description 
          "List of aliases"; 
        leaf alias-name {
          type string;
          description "alias name";
        }    
        leaf-list target-prefix {
          type inet:ip-prefix;
          description 
            "IPv4 or IPv6 prefix identifying the target.";
        }
        list target-port-range {
          key "lower-port upper-port";
          description 
            "Port range. When only lower-port is  
             present, it represents a single port.";
          leaf lower-port {
            type inet:port-number;
            mandatory true; 
            description 
              "Lower port number.";
          }
          leaf upper-port {
            type inet:port-number;
             must ". >= ../lower-port" {
               error-message
                 "The upper port number must be greater than  
                  or equal to the lower port number.";
            }
            description 
              "Upper port number.";
          }
        }
        leaf-list target-protocol {
          type uint8;
          description 
            "Identifies the target protocol number.

             The value '0' means 'all protocols'.
     
             Values are taken from the IANA protocol registry:
             https://www.iana.org/assignments/protocol-numbers/
             protocol-numbers.xhtml

             For example, 6 for a TCP or 17 for UDP.";
        }
        leaf-list target-fqdn {
          type inet:domain-name;
          description 
            "FQDN identifying the target.";
        }
        leaf-list target-uri {
          type inet:uri;
          description 
            "URI identifying the target.";
        }
      }
    }
  }
 
  augment "/ietf-acl:access-lists/ietf-acl:acl" {
    when "derived-from(ietf-acl:type, 'ietf-acl:ipv4-acl-type')" +
         " or derived-from(ietf-acl:type, 'ietf-acl:ipv6-acl-type')";

    description 
      "Augments ACLs with the identity of the DOTS 
       client, the client's domain identifier, and the lifetime.";
    leaf cuid {
      type leafref {
        path "/aliases/dots-client/cuid";
      }
      mandatory true;
      description
        "A unique identifier that is randomly 
         generated by a DOTS client to prevent 
         request collisions.";
    }
    leaf cdid {
      type leafref {
        path "/aliases/dots-client/cdid";
      }
      description
        "A client domain identifier conveyed by a server-domain DOTS
         gateway to a remote DOTS server.";
    }
    leaf lifetime {
      type int32;
      units "minutes";
      mandatory true;
      description  
        "Indicates the lifetime of the filtering rule
         
         A lifetime of negative one (-1) indicates indefinite
         lifetime for the filtering request.";
    }
  }

  augment "/ietf-acl:access-lists/ietf-acl:acl/ietf-acl:aces" +
          "/ietf-acl:ace/ietf-acl:actions" {
    description 
      "rate-limit action";
    leaf rate-limit {
      when "/ietf-acl:access-lists/ietf-acl:acl/ietf-acl:aces/" +
           "ietf-acl:ace/ietf-acl:actions/" + 
           "ietf-acl:forwarding = 'ietf-acl:accept'" {
      description 
        "rate-limit valid only when accept action is used";
      }
      type decimal64 {
        fraction-digits 2;
      }
     description 
       "rate-limit traffic";
     }
  }

  augment "/ietf-acl:access-lists/ietf-acl:acl/ietf-acl:aces" +
          "/ietf-acl:ace/ietf-acl:matches/ietf-acl:l3/ietf-acl:ipv4" {
    description 
      "Handle non-initial and initial fragments for IPv4 packets.";

    leaf v4-fragments {
      type empty;
      description 
        "Handle IPv4 fragments.";
    }
  }

  augment "/ietf-acl:access-lists/ietf-acl:acl/ietf-acl:aces" +
          "/ietf-acl:ace/ietf-acl:matches/ietf-acl:l3/ietf-acl:ipv6" {
    description 
      "Handle non-initial and initial fragments for IPv6 packets.";

    leaf v6-fragments {
      type empty;
      description 
        "Handle IPv6 fragments.";
    }
  }

  augment "/ietf-acl:access-lists" {
    description 
      "Handle ordering of ACLs from a DOTS client";
    
    container dots-acl-order {
      description
        "Enclosing container for ordering the ACLs from
         a DOTS client";

      list acl-set {
        key "cuid name";
        ordered-by user;
        description
          "List of ACLs";

        leaf cuid {
          type leafref {
            path "/ietf-acl:access-lists/ietf-acl:acl" +
                 "/cuid";
          }
          description
            "Reference to the client identifier";
        }
        leaf cdid {
          type leafref {
            path "/ietf-acl:access-lists/ietf-acl:acl" +
                 "/cdid";
          }
          description
            "Reference to the client domain identifier.";
        }
        leaf name {
          type leafref {
            path "/ietf-acl:access-lists/ietf-acl:acl" +
                 "/ietf-acl:name";
          }
          description
            "Reference to the ACL set name";
        }
        leaf type {
          type leafref {
            path "/ietf-acl:access-lists/ietf-acl:acl" +
                 "/ietf-acl:type";
          }
          description
            "Reference to the ACL set type";
        }
      }
    } 
  }
}
 <CODE ENDS>
]]></artwork>
          </figure></t>
      </section>
    </section>

    <section anchor="identifier" title="DOTS Aliases">
      <section title="Create Aliases">
        <t>A POST request is used to create aliases, for resources for which a
        mitigation may be requested. Such aliases may be used in subsequent
        DOTS signal channel exchanges to refer more efficiently to the
        resources under attack (<xref target="Figure1"></xref>).</t>

        <t>DOTS clients within the same domain can create different aliases
        for the same resource.</t>

        <t><figure anchor="Figure1" title="POST to Create Aliases">
            <artwork align="left"><![CDATA[ POST /restconf/data/ietf-dots-data-channel:aliases HTTP/1.1
 Host: {host}:{port}
 Content-Type: application/yang-data+json
 {
  "ietf-dots-data-channel:dots-client": {
    "cuid": "string",
    "alias": [
      {
        "alias-name": "string",
        "target-prefix": [
          "string"
        ],
        "target-port-range": [
          {
            "lower-port": integer,
            "upper-port": integer
          }
        ],
        "target-protocol": [
          integer
        ],
        "target-fqdn": [
          "string"
        ],
        "target-uri": [
          "string"
        ]
      }
    ]
  }
}]]></artwork>
          </figure></t>

        <t>The parameters are described below:</t>

        <t><list style="hanging">
            <t hangText="cuid:">A unique identifier that is meant to prevent
            collisions among DOTS clients that belong to the same domain. This
            attribute has the same meaning, syntax, and processing rules as
            the 'cuid' attribute defined in <xref
            target="I-D.ietf-dots-signal-channel"></xref>. <vspace
            blankLines="1" />This is a mandatory attribute.</t>

            <t hangText="alias-name:">Name of the alias. <vspace
            blankLines="1" />This is a mandatory attribute.</t>

            <t hangText="target-prefix: ">Prefixes are separated by commas.
            Prefixes are represented using Classless Inter-domain Routing
            (CIDR) notation <xref target="RFC4632"></xref>. As a reminder, the
            prefix length must be less than or equal to 32 (resp. 128) for
            IPv4 (resp. IPv6).<vspace blankLines="1" />This is an optional
            attribute.</t>

            <t hangText="target-port-range: ">A range of port numbers. <vspace
            blankLines="1" />The port range is defined by two bounds, a lower
            port number (lower-port) and an upper port number (upper-port).
            <vspace blankLines="1" />When only 'lower-port' is present, it
            represents a single port number. <vspace blankLines="1" />For TCP,
            UDP, Stream Control Transmission Protocol (SCTP) <xref
            target="RFC4960"></xref>, or Datagram Congestion Control Protocol
            (DCCP) <xref target="RFC4340"></xref>, the range of port numbers
            can be, for example, 1024-65535. <vspace blankLines="1" />This is
            an optional attribute.</t>

            <t hangText="target-protocol: ">A list of protocols. Values are
            taken from the IANA protocol registry <xref
            target="proto_numbers"></xref>. <vspace blankLines="1" />The value
            '0' has a special meaning for 'all protocols'. <vspace
            blankLines="1" />This is an optional attribute.</t>

            <t hangText="target-fqdn: ">A list of Fully Qualified Domain Names
            (FQDNs). An FQDN is the full name of a resource, rather than just
            its hostname. For example, "venera" is a hostname, and
            "venera.isi.edu" is an FQDN. <vspace blankLines="1" />This is an
            optional attribute.</t>

            <t hangText="target-uri: ">A list of Uniform Resource Identifiers
            (URIs) <xref target="RFC3986"></xref>. <vspace
            blankLines="1" />This is an optional attribute.</t>
          </list></t>

        <t>In deployments where server-domain DOTS gateways are enabled,
        identity information about the origin source client domain has to be
        supplied to the DOTS server. That information is meant to assist the
        DOTS server to enforce some policies. <xref target="Figure1a"></xref>
        shows an example of a request relayed by a server-domain DOTS
        gateway.<figure anchor="Figure1a"
            title="POST to Create Aliases (DOTS Gateway)">
            <artwork align="left"><![CDATA[ POST /restconf/data/ietf-dots-data-channel:aliases HTTP/1.1
 Host: {host}:{port}
 Content-Type: application/yang-data+json
 {
  "ietf-dots-data-channel:dots-client": {
    "cuid": "string",
    "cdid": "string",
    "alias": [
      {
        "alias-name": "string",
        "target-prefix": [
          "string"
        ],
        "target-port-range": [
          {
            "lower-port": integer,
            "upper-port": integer
          }
        ],
        "target-protocol": [
          integer
        ],
        "target-fqdn": [
          "string"
        ],
        "target-uri": [
          "string"
        ]
      }
    ]
  }
}]]></artwork>
          </figure>A server-domain DOTS gateway may add the following
        attribute:</t>

        <t><list style="hanging">
            <t hangText="cdid:">This attribute has the same meaning, syntax,
            and processing rules as the 'cdid' attribute defined in <xref
            target="I-D.ietf-dots-signal-channel"></xref>. <vspace
            blankLines="1" />This is an optional attribute.</t>
          </list></t>

        <t>In the POST request, at least one of the 'target-prefix',
        'target-fqdn', or 'target-uri' attributes MUST be present. DOTS agents
        can safely ignore Vendor-Specific parameters they don't
        understand.</t>

        <t><xref target="Figure2"></xref> shows a POST request to create alias
        called "https1" for HTTPS servers with IP addresses 2001:db8:6401::1
        and 2001:db8:6401::2 listening on port number 443.</t>

        <t><figure anchor="Figure2"
            title="Example of a POST to Create Aliases">
            <artwork align="left"><![CDATA[POST /restconf/data/ietf-dots-data-channel:aliases HTTP/1.1
Host: www.example.com
Content-Type: application/yang-data+json
{
  "ietf-dots-data-channel:dots-client": {
    "cuid": "dz6pHjaADkaFTbjr0JGBpw",
    "alias": [
      {
        "alias-name": "https1",
        "target-protocol": [
          6
        ],
        "target-prefix": [
          "2001:db8:6401::1/128",
          "2001:db8:6401::2/128"
        ],
        "target-port-range": [
          {
            "lower-port": 443
          }
        ]
      }
    ]
  }
}]]></artwork>
          </figure></t>

        <t>The DOTS server indicates the result of processing the POST request
        using status-line codes. Status codes in the range "2xx" codes are
        success, "4xx" codes are some sort of invalid requests and "5xx" codes
        are returned if the DOTS server has erred or is incapable of accepting
        the alias.</t>

        <t>"201 Created" status-line is returned in the response if the DOTS
        server has accepted the alias.</t>

        <t>If the request is missing one or more mandatory attributes, or if
        the request contains invalid or unknown parameters, then "400 Bad
        Request" status-line MUST be returned in the response. The HTTP
        response will include the JSON body received in the request.</t>

        <t>A DOTS client MAY use the PUT request (Section 4.5 in <xref
        target="RFC8040"></xref>) to create or modify the aliases in the DOTS
        server.</t>
      </section>

      <section title="Retrieve Installed Aliases">
        <t>A GET request is used to retrieve one or all installed aliases by a
        DOTS client from a DOTS server (Section 3.3.1 in <xref
        target="RFC8040"></xref>). If no 'alias-name' parameter is included in
        the request, this is an indication that the request is about
        retrieving all aliases instantiated by the DOTS client.</t>

        <t><xref target="Figure4"></xref> shows an example to retrieve all the
        aliases that were instantiated by the DOTS client. The content
        parameter and its permitted values are defined in Section 4.8.1 of
        <xref target="RFC8040"></xref>.</t>

        <figure anchor="Figure4" title="GET to Retrieve All Installed Aliases">
          <artwork align="left"><![CDATA[  GET /restconf/data/ietf-dots-data-channel:aliases\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw?content=config HTTP/1.1
  Host: {host}:{port}
  Accept: application/yang-data+json
]]></artwork>
        </figure>

        <t></t>

        <t><xref target="Figure6"></xref> shows an example of response message
        body that includes all the aliases that are maintained by the DOTS
        server for the DOTS client identified by the 'cuid' parameter.</t>

        <t><figure anchor="Figure6" title="An Example of Response Body">
            <artwork align="left"><![CDATA[{
  "ietf-dots-data-channel:dots-client": {
    "alias": [
      {
        "alias-name": "Server1",
        "traffic-protocol": [
          6
        ],
        "target-prefix": [
          "2001:db8:6401::1/128",
          "2001:db8:6401::2/128"
        ],
        "target-port-range": [
          {
            "lower-port": 443
          }
        ]
      },
      {
        "alias-name": "Server2",
        "target-protocol": [
          6
        ],
        "target-prefix": [
          "2001:db8:6401::10/128",
          "2001:db8:6401::20/128"
        ],
        "target-port-range": [
          {
            "lower-port": 80
          }
        ]
      }
    ]
  }
}]]></artwork>
          </figure></t>

        <t><xref target="analias"></xref> shows an example to retrieve the
        alias "Server2" that was instantiated by the DOTS client. <figure
            anchor="analias" title="GET to Retrieve an Alias">
            <artwork align="left"><![CDATA[  GET /restconf/data/ietf-dots-data-channel:aliases\
      /dots-client=dz6pHjaADkaFTbjr0JGBpw\
      /alias=Server2?content=config HTTP/1.1
  Host: {host}:{port}
  Accept: application/yang-data+json]]></artwork>
          </figure></t>

        <t>If the 'alias-name' parameter is included in the request, but the
        DOTS server does not find that alias name in its configuration data,
        it MUST respond with a "404 Not Found" status-line.</t>
      </section>

      <section title="Delete Aliases">
        <t>A DELETE request is used to delete an alias maintained by a DOTS
        server. </t>

        <t>In RESTCONF, URI-encoded path expressions are used. A RESTCONF data
        resource identifier is encoded from left to right, starting with the
        top-level data node, according to the 'api-path' rule defined in
        Section 3.5.3.1 of <xref target="RFC8040"></xref>. The data node in
        the path expression is a YANG list node and MUST be encoded according
        to the rules defined in Section 3.5.1 of <xref
        target="RFC8040"></xref>.</t>

        <t>If the DOTS server does not find the alias name conveyed in the
        DELETE request in its configuration data, it MUST respond with a "404
        Not Found" status-line.</t>

        <t>The DOTS server successfully acknowledges a DOTS client's request
        to remove the alias using "204 No Content" status-line in the
        response.</t>

        <t><xref target="Figure3"></xref> shows an example of a request to
        delete an alias.</t>

        <t><figure anchor="Figure3" title="Delete an Alias">
            <artwork align="left"><![CDATA[  DELETE /restconf/data/ietf-dots-data-channel:aliases\
         /dots-client=dz6pHjaADkaFTbjr0JGBpw\
         /alias=Server1 HTTP/1.1
  Host: {host}:{port}]]></artwork>
          </figure></t>
      </section>
    </section>

    <section anchor="filter" title="DOTS Filtering Rules">
      <t>The DOTS server either receives the filtering rules directly from the
      DOTS client or via a DOTS gateway.</t>

      <t>If the DOTS client signals the filtering rules via a DOTS gateway,
      the DOTS gateway first verifies that the DOTS client is authorized to
      signal the filtering rules. If the client is authorized, it propagates
      the rules to the DOTS server. Likewise, the DOTS server verifies that
      the DOTS gateway is authorized to signal the filtering rules. To create
      or purge filters, the DOTS client sends HTTP requests to its DOTS
      gateway. The DOTS gateway validates the rules in the requests and
      proxies the requests containing the filtering rules to a DOTS server.
      When the DOTS gateway receives the associated HTTP response from the
      DOTS server, it propagates the response back to the DOTS client.</t>

      <t>The following sub-sections define means for a DOTS client to
      configure filtering rules on a DOTS server.</t>

      <section anchor="install" title="Install Filtering Rules">
        <t>A POST request is used to push filtering rules to a DOTS
        server.</t>

        <t><xref target="Figure7"></xref> shows a POST request example to
        block traffic from 192.0.2.0/24 and destined to 198.51.100.0/24. The
        ACL JSON configuration for the filtering rule is generated using the
        ACL YANG module (Section 4.3 of <xref
        target="I-D.ietf-netmod-acl-model"></xref>).</t>

        <t><figure anchor="Figure7" title="POST to Install Filtering Rules">
            <artwork align="left"><![CDATA[POST /restconf/data/ietf-access-control-list HTTP/1.1
Host: www.example.com
Content-Type: application/yang-data+json
{
  "ietf-access-control-list:access-lists": {
    "acl": [
      {
        "name": "sample-ipv4-acl",
        "type": "ipv4-acl-type",
        "data-channel:cuid": "dz6pHjaADkaFTbjr0JGBpw",
        "data-channel:lifetime": 10080,
        "aces": {
          "ace": [
            {
              "name": "rule1",
              "matches": {
                "l3": {
                  "ipv4" {
                     "destination-ipv4-network": "198.51.100.0/24"
                     "source-ipv4-network": "192.0.2.0/24",
                  }
                }
              },
              "actions": {
                "forwarding": "drop"
              }
            }
          ]
        }
      }
    ]
  }
}]]></artwork>
          </figure></t>

        <t>The meaning of these parameters is as follows:</t>

        <t><list style="hanging">
            <t hangText="name:">The name of the access-list. <vspace
            blankLines="1" />This is a mandatory attribute.</t>

            <t hangText="type:">Indicates the primary intended type of match
            criteria (e.g., IPv4, IPv6). It is set to 'ipv4-acl-type' in this
            example. <vspace blankLines="1" />This is a mandatory
            attribute.</t>

            <t hangText="cuid:">A unique identifier that is meant to prevent
            collisions among DOTS clients that belong to the same domain <xref
            target="I-D.ietf-dots-signal-channel"></xref>. <vspace
            blankLines="1" />This is a mandatory attribute.</t>

            <t hangText="lifetime:">Lifetime of the ACL, in minutes. The
            RECOMMENDED lifetime of a ACL is 10080 minutes (1 week). DOTS
            clients MUST include this parameter in their filtering requests.
            Upon the expiry of this lifetime, and if the request is not
            refreshed but no mitigation is active, the filtering request is
            removed. The request can be refreshed by sending the same request
            again. <vspace blankLines="1" />A lifetime of '0' in a request is
            an invalid value. <vspace blankLines="1" />A lifetime of negative
            one (-1) indicates indefinite lifetime for the filtering request.
            The DOTS server MAY refuse indefinite lifetime, for policy
            reasons; the granted lifetime value is returned in the response.
            DOTS clients MUST be prepared to not be granted filtering with
            indefinite lifetimes.<vspace blankLines="1" />The DOTS server MUST
            always indicate the actual lifetime in the response and the
            remaining lifetime in status messages sent to the DOTS client.
            <vspace blankLines="1" />This is a mandatory attribute.</t>

            <t hangText="matches:">Define criteria used to identify a flow on
            which to apply the rule. It can be "l3" (IPv4, IPv6) or "l4" (TCP,
            UDP, ..). In this example, an IPv4 matching criteria is used.</t>

            <t hangText="destination-ipv4-network:">The destination IPv4
            prefix. <vspace blankLines="1" />This is an optional
            attribute.</t>

            <t hangText="source-ipv4-network:">The source IPv4 prefix. <vspace
            blankLines="1" />This is an optional attribute.</t>

            <t hangText="actions: ">Actions in the forwarding ACL category can
            be "drop" or "accept" or "rate-limit". The "accept" action is used
            to white-list traffic. The "drop" action is used to black-list
            traffic. The "rate-limit" action is used to rate-limit traffic,
            the allowed traffic rate is represented in bytes per second
            indicated in IEEE floating point format <xref
            target="IEEE.754.1985"></xref>. <vspace blankLines="1" />This is a
            mandatory attribute.</t>
          </list></t>

        <t>The DOTS server indicates the result of processing the POST request
        using the status-line header. "2xx" codes are success, 4xx codes are
        some sort of invalid requests, and 5xx codes are returned if the DOTS
        server has erred or is incapable of configuring the filtering rules.
        Concretely, "201 Created" status-line MUST be returned in the response
        if the DOTS server has accepted the filtering rules. If the request is
        missing one or more mandatory attributes or contains invalid or
        unknown parameters, then "400 Bad Request" status-line MUST be
        returned in the response.</t>

        <t>If the request is conflicting with an existing filtering, the DOTS
        server returns "409 Conflict" status-line to the requesting DOTS
        client. The error-tag "invalid-value" is used in this case.</t>

        <t>The "insert" query parameter (Section 4.8.5 of <xref
        target="RFC8040"></xref>) MAY be used to specify how an Access Control
        Entry (ACE) is inserted within an ACL and how an ACL is inserted
        within an ACL set in container dots-acl-order.</t>

        <t>The DOTS client MAY use the PUT request to create or modify the
        filtering rules in the DOTS server.</t>
      </section>

      <section title="Retrieve Installed Filtering Rules  ">
        <t>The DOTS client periodically queries the DOTS server to check the
        counters for installed filtering rules. A GET request is used to
        retrieve filtering rules from a DOTS server.</t>

        <t>If the DOTS server does not find the access list name conveyed in
        the GET request in its configuration data, it responds with a "404 Not
        Found" status-line.</t>

        <t><xref target="Figure10"></xref> shows how to retrieve all the
        filtering rules programmed by the DOTS client and the number of
        matches for the installed filtering rules.</t>

        <figure anchor="Figure10"
                title="GET to Retrieve the Configuration Data and State Data for the Filtering Rules">
          <artwork align="left"><![CDATA[NO GW:

  GET /restconf/data/ietf-access-control-list:access-lists?\
      content=all HTTP/1.1
  Host: {host}:{port}
  Accept: application/yang-data+json]]></artwork>
        </figure>

        <t></t>

        <t><xref target="Figure10a"></xref> shows how to retrieve
        "sample-ipv6-acl" filtering rule programmed by the DOTS client and the
        number of matches for the installed filtering rules.</t>

        <t><figure anchor="Figure10a"
            title="GET to Retrieve the Configuration Data and State Data for a Filtering Rule">
            <artwork align="left"><![CDATA[NO GW:

  GET /restconf/data/ietf-access-control-list:access-lists\
      /acl=sample-ipv6-acl?content=all HTTP/1.1
  Host: {host}:{port}
  Accept: application/yang-data+json]]></artwork>
          </figure></t>
      </section>

      <section title="Remove Filtering Rules">
        <t>A DELETE request is used to delete filtering rules from a DOTS
        server.</t>

        <t>If the DOTS server does not find the access list name and access
        list type carried in the DELETE request in its configuration data, it
        responds with a "404 Not Found" status-line. The DOTS server
        successfully acknowledges a DOTS client's request to withdraw the
        filtering rules using "204 No Content" status-line, and removes the
        filtering rules accordingly.</t>

        <t><xref target="Figure9"></xref> shows an example of a request to
        remove the IPv4 ACL named "sample-ipv4-acl".</t>

        <figure anchor="Figure9" title="DELETE to Remove a Filtering Rule">
          <artwork align="left"><![CDATA[NO GW:

  DELETE /restconf/data/ietf-access-control-list:access-lists\
         /acl=sample-ipv4-acl HTTP/1.1
  Host: {host}:{port}]]></artwork>
        </figure>

        <t></t>
      </section>
    </section>

    <section title="IANA Considerations">
      <t>This document requests IANA to register the following URI in the
      "IETF XML Registry" <xref target="RFC3688"></xref>: <figure>
          <artwork><![CDATA[         URI: urn:ietf:params:xml:ns:yang:ietf-dots-data-channel
         Registrant Contact: The IESG.
         XML: N/A; the requested URI is an XML namespace.
]]></artwork>
        </figure> This document requests IANA to register the following YANG
      module in the "YANG Module Names" registry <xref
      target="RFC7950"></xref>.<figure>
          <artwork><![CDATA[         name: ietf-dots-data-channel
         namespace: urn:ietf:params:xml:ns:yang:ietf-dots-data-channel
         prefix: data-channel
         reference: RFC XXXX]]></artwork>
        </figure></t>
    </section>

    <section anchor="contr" title="Contributors">
      <t>The following individuals have contributed to this document:</t>

      <t>Dan Wing</t>

      <t>Email: dwing-ietf@fuggles.com</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>RESTCONF security considerations are discussed in <xref
      target="RFC8040"></xref>. In particular, DOTS agents MUST follow the
      security recommendations in Sections 2 and 12 of <xref
      target="RFC8040"></xref> and support the mutual authentication TLS
      profile discussed in Sections 7.1 and 8 of <xref
      target="I-D.ietf-dots-signal-channel"></xref>.</t>

      <t>Authenticated encryption MUST be used for data confidentiality and
      message integrity. The interaction between the DOTS agents requires
      Transport Layer Security (TLS) with a cipher suite offering
      confidentiality protection and the guidance given in <xref
      target="RFC7525"></xref> MUST be followed to avoid attacks on TLS.</t>

      <t>An attacker may be able to inject RST packets, bogus application
      segments, etc., regardless of whether TLS authentication is used.
      Because the application data is TLS protected, this will not result in
      the application receiving bogus data, but it will constitute a DoS on
      the connection. This attack can be countered by using TCP-AO <xref
      target="RFC5925"></xref>. If TCP-AO is used, then any bogus packets
      injected by an attacker will be rejected by the TCP-AO integrity check
      and therefore will never reach the TLS layer.</t>

      <t>In order to prevent leaking internal information outside a
      client-domain, client-side DOTS gateways SHOULD NOT reveal the identity
      of internal DOTS clients (e.g., source IP address, client's hostname)
      unless explicitly configured to do so.</t>

      <t>Special care should be taken in order to ensure that the activation
      of the proposed mechanism will not affect the stability of the network
      (including connectivity and services delivered over that network).</t>

      <t>All data nodes defined in the YANG module which can be created,
      modified, and deleted (i.e., config true, which is the default) are
      considered sensitive. Write operations applied to these data nodes
      without proper protection can negatively affect network operations.
      Appropriate security measures are recommended to prevent illegitimate
      users from invoking DOTS data channel primitives. Nevertheless, an
      attacker who can access a DOTS client is technically capable of
      launching various attacks, such as:<list style="symbols">
          <t>Set an arbitrarily low rate-limit, which may prevent legitimate
          traffic from being forwarded (rate-limit).</t>

          <t>Set an arbitrarily high rate-limit, which may lead to the
          forwarding of illegitimate DDoS traffic (rate-limit).</t>

          <t>Communicate invalid aliases to the server (alias), which will
          cause the failure of associating both data and signal channels.</t>

          <t>Set invalid ACL entries, which may prevent legitimate traffic
          from being forwarded. Likewise, invalid ACL entries may lead to
          forward DDoS traffic.</t>
        </list></t>
    </section>

    <section anchor="ack" title="Acknowledgements">
      <t>Thanks to Christian Jacquenet, Roland Dobbins, Roman Danyliw, Ehud
      Doron, Russ White, Jon Shallow, Gilbert Clark, and Nesredien Suleiman
      for the discussion and comments.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>

      <?rfc include="reference.RFC.7525"?>

      <?rfc include="reference.RFC.5925"
?>

      <?rfc include="reference.RFC.8040"?>

      <?rfc include="reference.I-D.ietf-netmod-acl-model"?>

      <?rfc include="reference.I-D.ietf-dots-signal-channel"?>

      <?rfc include="reference.RFC.5246"?>

      <?rfc include="reference.RFC.7951"?>

      <?rfc include="reference.RFC.7230"?>

      <?rfc include='reference.RFC.3688'?>

      <?rfc include='reference.RFC.8126'?>

      <?rfc include='reference.RFC.4632'?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.7159"?>

      <?rfc include="reference.RFC.6020"?>

      <?rfc include="reference.I-D.ietf-dots-architecture"?>

      <?rfc include='reference.RFC.4340'?>

      <?rfc include="reference.RFC.7950"?>

      <?rfc include="reference.RFC.6520"?>

      <?rfc include='reference.RFC.5389'?>

      <?rfc include='reference.RFC.7223'?>

      <?rfc include='reference.RFC.3986'?>

      <?rfc include='reference.RFC.6887'?>

      <?rfc include="reference.RFC.6241"?>

      <?rfc include='reference.RFC.4960'?>

      <?rfc include="reference.I-D.ietf-dots-requirements"?>

      <?rfc include='reference.I-D.ietf-netmod-yang-tree-diagrams'?>

      <reference anchor="IEEE.754.1985">
        <front>
          <title>Standard for Binary Floating-Point Arithmetic</title>

          <author>
            <organization>Institute of Electrical and Electronics
            Engineers</organization>
          </author>

          <date month="August" year="1985" />
        </front>
      </reference>

      <reference anchor="proto_numbers"
                 target="http://www.iana.org/assignments/protocol-numbers">
        <front>
          <title>IANA, "Protocol Numbers"</title>

          <author>
            <organization></organization>
          </author>

          <date year="2011" />
        </front>
      </reference>
    </references>
  </back>
</rfc>
